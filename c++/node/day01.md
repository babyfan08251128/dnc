# 命名空间
允许将一组标识符(变量，函数，类等)封装在一个特定的作用域，提供了一种将全局作用域划分为更小，更可管理的单元的方式  

作用:划分更精细的逻辑单元，避免命名冲突  
### 命名空间使用：  
  
### 命名空间指令：  
### 命名空间声明：  
### 命名空间嵌套：  

# 复合类型
# 函数缺省参数

## 结构体与类的区别
### 不同:  
结构体：默认为*公有权限*  默认继承权限为*公有继承*  
类：默认为*私有权限*  默认继承权限为*私有继承*  
### 相同：
都可以包含成员变量和成员函数.  
都具有构造函数，析构函数，成员函数。
进行数据封装

```cpp
#include <iostream>

// 结构体
struct PointStruct {
    int x, y;
};

// 类
class PointClass {
private:
    int x, y;

public:
    // 构造函数
    PointClass(int x, int y) : x(x), y(y) {}

    // 成员函数
    void print() {
        std::cout << "PointClass: (" << x << ", " << y << ")" << std::endl;
    }
};

int main() {
    // 使用结构体
    PointStruct ps = {1, 2};
    std::cout << "PointStruct: (" << ps.x << ", " << ps.y << ")" << std::endl;

    // 使用类
    PointClass pc(3, 4);
    pc.print();

    return 0;
}
```

## 联合体

## 枚举

## 布尔

 

初始化列表：
 常量型成员变量 (const float m_score)：常量成员变量必须在对象创建时初始化，不能在构造函数体内赋值。因此，必须使用初始化列表来进行初始化。

 引用类型的成员变量：引用类型的成员变量也必须在对象创建时初始化，不能在构造函数体内赋值。

 没有默认构造函数的类类型成员变量：如果成员变量是一个类的对象，而该类没有默认构造函数，必须使用初始化列表来初始化该成员变量。

 效率考虑：对于简单的内置类型（如 int），使用初始化列表可以避免先默认初始化再赋值的过程，从而提高效率。